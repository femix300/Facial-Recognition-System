{% extends 'attendance/base.html' %}
{% block title %}Attendance Kiosk - {{ course.course_name }}{% endblock %}

{% block content %}
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">

<style>
    :root {
        --primary-color: #0d6efd;
        --success-color: #198754;
        --error-color: #dc3545;
        --warning-color: #ffc107;
        --neutral-color: rgba(255, 255, 255, 0.5);
    }
  
    .kiosk-wrapper {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-height: 85vh;
        background-color: #111827;
        color: #ffffff;
        font-family: 'Poppins', sans-serif;
        padding: 1rem;
    }
    #camera-container {
        border-radius: 50%;
        overflow: hidden;
        border: 6px solid var(--neutral-color);
        transition: border-color 0.5s ease;
        position: relative;
        box-shadow: 0 0 30px rgba(0, 123, 255, 0.3);
    }
    #status {
        font-size: 2rem;
        font-weight: 600;
        min-height: 84px;
        display: flex;
        align-items: center;
        justify-content: center;
        text-align: center;
        transition: all 0.5s ease-in-out;
    }
    
    .challenge-icon { display: none; margin-bottom: 1.5rem; height: 60px; }
    .challenge-icon.active { display: block; }
    @keyframes blink-animation { 0%, 100% { transform: scaleY(1); } 50% { transform: scaleY(0.1); } }
    #blink-icon { animation: blink-animation 1.5s infinite; font-size: 4rem; }
    @keyframes mouth-animation { 0%, 100% { transform: scaleY(0.2); } 50% { transform: scaleY(1); } }
    #mouth-icon-shape { width: 60px; height: 30px; border: 4px solid white; border-top: none; border-radius: 0 0 60px 60px; transform-origin: top center; }
    #mouth-icon.active #mouth-icon-shape { animation: mouth-animation 1.5s infinite; }
    @keyframes turn-head-animation { 0%, 100% { transform: translateX(0) scaleX(1); } 25% { transform: translateX(-15px) scaleX(0.9); } 75% { transform: translateX(15px) scaleX(0.9); } }
    #head-turn-icon { animation: turn-head-animation 2s infinite; font-size: 4rem; }
    
    .progress-dots { display: flex; gap: 0.75rem; margin-top: 1rem; height: 16px; }
    .dot { width: 16px; height: 16px; background-color: rgba(255,255,255,0.3); border-radius: 50%; transition: background-color 0.5s ease; }
    .dot.completed { background-color: #ffffff; }

    .result-overlay {
        position: absolute;
        top: 0; left: 0; right: 0; bottom: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        background-color: rgba(17, 24, 39, 0.8);
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.5s ease, visibility 0.5s ease;
        border-radius: 50%;
        backdrop-filter: blur(5px);
        text-align: center;
    }
    .result-overlay.show { opacity: 1; visibility: visible; }
    .result-overlay .icon {
        font-size: 4.5rem;
        animation: pop-in 0.5s ease;
    }
    .result-overlay .name {
        font-size: 1.6rem;
        font-weight: 600;
        margin-top: 0.75rem;
        animation: pop-in 0.5s ease 0.1s;
    }
    .result-overlay .message {
        font-size: 1rem;
        font-weight: 400;
        margin-top: 0.25rem;
        color: rgba(255, 255, 255, 0.7);
        padding: 0 1rem;
        animation: pop-in 0.5s ease 0.2s;
    }
    @keyframes pop-in { from { transform: scale(0.5); opacity: 0; } to { transform: scale(1); opacity: 1; } }

    .log-panel {
        background: rgba(255, 255, 255, 0.05);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 1rem;
        height: 75vh;
    }
    .log-panel .list-group-item {
        background: transparent !important;
        color: #ffffff !important;
        border-color: rgba(255, 255, 255, 0.1) !important;
    }
    .log-panel .list-group-item small { color: #adb5bd !important; }
</style>

<div class="kiosk-wrapper">
    <div class="container-fluid">
        <div class="row align-items-center">
            <div class="col-lg-7 d-flex flex-column align-items-center justify-content-center">
                <h2 class="text-center mb-3">Attendance for <strong>{{ course.course_name }}</strong></h2>
                
                <div class="challenge-icon" id="blink-icon"><i class="bi bi-eye-fill"></i></div>
                <div class="challenge-icon" id="mouth-icon"><div id="mouth-icon-shape"></div></div>
                <div class="challenge-icon" id="head-turn-icon"><i class="bi bi-person-badge"></i></div>

                <div id="camera-container" class="shadow-lg mx-auto" style="width: 100%; max-width: 400px; aspect-ratio: 1/1;">
                    <video id="video" class="w-100 h-100" style="object-fit: cover; transform: scaleX(-1);" autoplay playsinline muted></video>
                    <canvas id="overlay_canvas" class="w-100 h-100" style="position: absolute; top: 0; left: 0; transform: scaleX(-1);"></canvas>
                    <div id="result-overlay" class="result-overlay">
                        <div id="result-icon" class="icon"></div>
                        <h3 id="result-name" class="name"></h3>
                        <p id="result-message" class="message"></p> 
                    </div>
                </div>
                
                <div id="progress-dots" class="progress-dots"></div>
                <h3 id="status" class="mt-4 text-center">Initializing Camera...</h3>
            </div>

            <div class="col-lg-5 mt-4 mt-lg-0">
                <div class="log-panel p-3">
                    <div class="d-flex justify-content-between align-items-center mb-3 px-2">
                        <h4 class="mb-0">Attendance Log</h4>
                        <span class="badge bg-light text-dark fs-6" id="attendee_count">0</span>
                    </div>
                    <div style="height: calc(75vh - 100px); overflow-y: auto;">
                        <ul id="attendance-log" class="list-group list-group-flush">
                            <li class="list-group-item text-center">Waiting for first scan...</li>
                        </ul>
                    </div>
                    <div class="text-center pt-3 border-top border-secondary">
                        <strong>Last Student:</strong> <span id="last-student">None</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<canvas id="capture_canvas" style="display:none;"></canvas>
{% endblock %}

{% block scripts %}
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>

<script type="module">
    // --- Get references to all UI elements ---
  
    const video = document.getElementById('video');
    const statusDiv = document.getElementById('status');
    const attendanceLog = document.getElementById('attendance-log');
    const lastStudentSpan = document.getElementById('last-student');
    const captureCanvas = document.getElementById('capture_canvas');
    const overlayCanvas = document.getElementById('overlay_canvas');
    const cameraContainer = document.getElementById('camera-container');
    const attendeeCount = document.getElementById('attendee_count');
    const canvasCtx = overlayCanvas.getContext('2d');
    const progressDotsContainer = document.getElementById('progress-dots');
    const resultOverlay = document.getElementById('result-overlay');
    const resultIcon = document.getElementById('result-icon');
    const resultName = document.getElementById('result-name');
    const sessionId = "{{ session_id }}";
    
    let blinkState = {
        wasOpen: true 
    };
    
    let isProcessing = false;
    let isTransitioning = false;

  
    const challenges = {
        BLINK: {
            instruction: "Please Blink Your Eyes",
            iconId: "blink-icon",
            detectionFunction: (landmarks) => {
                const leftEyeIndices = [33, 160, 158, 133, 153, 144];
                const rightEyeIndices = [362, 385, 387, 263, 373, 380];
                const getEAR = (eyeIndices) => {
                    const p1 = landmarks[eyeIndices[3]], p2 = landmarks[eyeIndices[1]], p3 = landmarks[eyeIndices[2]], p4 = landmarks[eyeIndices[0]], p5 = landmarks[eyeIndices[5]], p6 = landmarks[eyeIndices[4]];
                    const verDist = Math.hypot(p2.y - p6.y, p2.x - p6.x) + Math.hypot(p3.y - p5.y, p3.x - p5.x);
                    const horDist = Math.hypot(p1.y - p4.y, p1.x - p4.x);
                    return (horDist === 0) ? 0 : verDist / (2.0 * horDist);
                };
                
                const avgEAR = (getEAR(leftEyeIndices) + getEAR(rightEyeIndices)) / 2.0;
                const isClosed = avgEAR < 0.23; 
    
                let blinked = false;
                if (blinkState.wasOpen && isClosed) {
                    blinked = true;
                }

                // Update the state for the next frame.
                blinkState.wasOpen = !isClosed;

                return blinked;
            }
        },
        MOUTH_OPEN: {
            instruction: "Please Open Your Mouth",
            iconId: "mouth-icon",
            detectionFunction: (landmarks) => {
                const topLip = landmarks[13];
                const bottomLip = landmarks[14];
                const leftCorner = landmarks[61];
                const rightCorner = landmarks[291];
        
                const verticalDist = Math.hypot(topLip.y - bottomLip.y, topLip.x - bottomLip.x);
                const horizontalDist = Math.hypot(leftCorner.y - rightCorner.y, leftCorner.x - rightCorner.x);
                
                if (horizontalDist === 0) return false;
        
                const mar = verticalDist / horizontalDist;
                return mar > 0.5; // Threshold for a clearly open mouth
            }
        },
        TURN_HEAD: {
            instruction: "Please Turn Your Head",
            iconId: "head-turn-icon",
            detectionFunction: (landmarks) => {
                const nose = landmarks[1], leftEdge = landmarks[234], rightEdge = landmarks[454];
                const turnRatio = Math.abs(nose.x - leftEdge.x) / Math.abs(nose.x - rightEdge.x);
                return turnRatio > 2.0 || (1 / turnRatio) > 2.0;
            }
        }
    };
    
    let challengeSequence = [];
    let currentChallengeIndex = 0;

    // --- 2. STATE MACHINE & UI FUNCTIONS ---
    function generateChallengeSequence() {
        const challengeKeys = Object.keys(challenges);
        for (let i = challengeKeys.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [challengeKeys[i], challengeKeys[j]] = [challengeKeys[j], challengeKeys[i]];
        }
        const numChallenges = Math.floor(Math.random() * 2) + 1; // 1 or 2 challenges
        challengeSequence = challengeKeys.slice(0, numChallenges);
        currentChallengeIndex = 0;
    }

    function startLivenessCheck() {
        isProcessing = false;
        resultOverlay.classList.remove('show');
        blinkState = { wasOpen: true, detected: false };
        generateChallengeSequence();
        updateInstruction();
    }

    function updateInstruction() {
        if (currentChallengeIndex >= challengeSequence.length) return;
        const currentChallengeKey = challengeSequence[currentChallengeIndex];
        statusDiv.textContent = challenges[currentChallengeKey].instruction;
        
        document.querySelectorAll('.challenge-icon').forEach(icon => icon.classList.remove('active'));
        document.getElementById(challenges[currentChallengeKey].iconId).classList.add('active');

        progressDotsContainer.innerHTML = '';
        for (let i = 0; i < challengeSequence.length; i++) {
            const dot = document.createElement('div');
            dot.className = 'dot' + (i < currentChallengeIndex ? ' completed' : '');
            progressDotsContainer.appendChild(dot);
        }
    }

  
    const faceMesh = new FaceMesh({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`});
    faceMesh.setOptions({ maxNumFaces: 1, refineLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
    faceMesh.onResults(onResults);
    
    const camera = new Camera(video, { onFrame: async () => { await faceMesh.send({image: video}); }, width: 640, height: 480 });
    

    camera.start()
        .then(() => {
            overlayCanvas.width = video.videoWidth;
            overlayCanvas.height = video.videoHeight;
            startLivenessCheck();
        })
        .catch(err => {
            console.error("Camera Error:", err);
            statusDiv.textContent = "Camera access denied or unavailable.";
            cameraContainer.style.borderColor = 'var(--error-color)';
        });

    function onResults(results) {
        canvasCtx.save();
        canvasCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
    
        // Block processing during transitions or when sending data
        if (isProcessing || isTransitioning) { 
            canvasCtx.restore(); 
            return; 
        }
    
        if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
            const landmarks = results.multiFaceLandmarks[0];
            drawConnectors(canvasCtx, landmarks, FACEMESH_TESSELATION, {color: 'var(--neutral-color)', lineWidth: 1});
            cameraContainer.style.borderColor = 'var(--primary-color)';
    
            const currentChallengeKey = challengeSequence[currentChallengeIndex];
            if (!currentChallengeKey) { canvasCtx.restore(); return; }
            const challenge = challenges[currentChallengeKey];
    
            if (challenge.detectionFunction(landmarks)) {
                isTransitioning = true; // Start the transition to block other actions
                currentChallengeIndex++;
    
                if (currentChallengeIndex >= challengeSequence.length) {
                    isProcessing = true; 
                    isTransitioning = false;
                    statusDiv.textContent = 'Liveness Confirmed!';
                    drawConnectors(canvasCtx, landmarks, FACEMESH_TESSELATION, {color: 'var(--success-color)', lineWidth: 2});
                    cameraContainer.style.borderColor = 'var(--success-color)';
                    setTimeout(captureAndSendImage, 500);
                } else {
                    // Show temporary feedback, then show the next instruction
                    statusDiv.textContent = '✅ Great! Next...';
                    setTimeout(() => {
                        updateInstruction();
                        isTransitioning = false; // End transition, ready for next detection
                    }, 1200); // 1.2 second pause for user to see feedback
                }
            }
        } else {
            cameraContainer.style.borderColor = 'var(--neutral-color)';
        }
        canvasCtx.restore();
    }

    function captureAndSendImage() {
        captureCanvas.width = video.videoWidth; 
        captureCanvas.height = video.videoHeight;
        const ctx = captureCanvas.getContext('2d');
        ctx.translate(video.videoWidth, 0);
        ctx.scale(-1, 1);
        ctx.drawImage(video, 0, 0, captureCanvas.width, captureCanvas.height);
        const imageData = captureCanvas.toDataURL('image/jpeg', 0.9);

        fetch("{% url 'process_frame_api' %}", {
            method: 'POST',
            headers: {'Content-Type': 'application/json', 'X-CSRFToken': '{{ csrf_token }}'}, // Good practice to include CSRF token
            body: JSON.stringify({ image: imageData, session_id: sessionId })
        })
        .then(response => response.json())
        .then(handleApiResponse)
        .catch(err => {
            console.error('API Error:', err);
            handleApiResponse({status: 'error', message: 'Connection Error'});
        });
    }

    function handleApiResponse(data) {
        let overlayColor, iconClass, studentName, messageText = '';
    
        if (data.status === 'success') {
            overlayColor = 'var(--success-color)';
            iconClass = 'bi bi-check-circle-fill text-success';
            studentName = data.student_name;
            messageText = `Matric: ${data.matric_number}`;
            updateLog(data.student_name, data.matric_number, new Date().toLocaleTimeString());
        } else if (data.status === 'already_marked') {
            overlayColor = 'var(--warning-color)';
            iconClass = 'bi bi-info-circle-fill text-warning';
            studentName = data.student_name;
            messageText = "Already marked for this session.";
        } else {
            overlayColor = 'var(--error-color)';
            iconClass = 'bi bi-x-circle-fill text-danger';
            studentName = "Verification Failed";
            messageText = data.message || "An unknown error occurred.";
        }
    
        // Clear previous message
        document.getElementById('result-message').textContent = '';
    
        cameraContainer.style.borderColor = overlayColor;
        resultIcon.className = 'icon ' + iconClass;
        resultName.textContent = studentName;
        document.getElementById('result-message').textContent = messageText; // Set the new message
        resultOverlay.classList.add('show');
    
        setTimeout(startLivenessCheck, 4000); // Increased timeout slightly
    }

    function updateLog(studentName, matricNumber, timestamp) {
        const initialItem = attendanceLog.querySelector('.list-group-item.text-center');
        if (initialItem) initialItem.remove();
        
        const logItem = document.createElement('li');
        logItem.className = 'list-group-item d-flex justify-content-between align-items-center';
        logItem.innerHTML = `<div><strong>${studentName}</strong><br><small>${matricNumber}</small></div> <span class="badge bg-light text-dark rounded-pill">${timestamp}</span>`;
        attendanceLog.prepend(logItem);
        
        lastStudentSpan.textContent = studentName;
        attendeeCount.textContent = attendanceLog.children.length;
    }
</script>
{% endblock %}